<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>uGFX: GADC</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">uGFX
   &#160;<span id="projectnumber">2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___g_a_d_c.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#groups">Modules</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">GADC</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for GADC:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group___g_a_d_c.png" border="0" alt="" usemap="#group______g__a__d__c"/>
<map name="group______g__a__d__c" id="group______g__a__d__c">
<area shape="rect" id="node1" href="group___driver.html" title="Driver" alt="" coords="107,5,157,29"/></map>
</td></tr></table></center>
</div>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Module to abstract the very variable ADC interfaces of the underlying systems. </p>
<p>The reason why ChibiOS/GFX has it's own ADC abstraction is because the Chibi-OS drivers are very CPU specific and do not provide a way across all hardware platforms to create periodic ADC conversions. There are also issues with devices with different characteristics or periodic requirements on the same ADC device (but different channels). This layer attempts to solve these problems to provide a architecture neutral API. It also provides extra features such as multi-buffer chaining for high speed ADC sources. It provides one high speed virtual ADC device (eg a microphone) and numerous low speed (less than 100Hz) virtual ADC devices (eg dials, temperature sensors etc). The high speed device has timer based polling to ensure exact conversion periods and a buffer management system. The low speed devices are assumed to be non-critical timing devices and do not have any buffer management. Note that while only one high speed device has been provided it can be used to read multiple physical ADC channels on the one physical ADC device. All callback routines are thread based unlike the Chibi-OS interrupt based routines. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_event_a_d_c__t.html">GEventADC_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The High Speed ADC event structure.  <a href="struct_g_event_a_d_c__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group___driver"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___driver.html">Driver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga78977f898a9d53f739c9bf9a1867fd0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_d_c.html#ga78977f898a9d53f739c9bf9a1867fd0b">gadcHighSpeedInit</a> (uint32_t physdev, uint32_t frequency, adcsample_t *buffer, <a class="el" href="group___g_o_s.html#gacf18a0d6c4b39d531e021702e9a77984">size_t</a> bufcount, <a class="el" href="group___g_o_s.html#gacf18a0d6c4b39d531e021702e9a77984">size_t</a> samplesPerEvent)</td></tr>
<tr class="memdesc:ga78977f898a9d53f739c9bf9a1867fd0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise the high speed ADC.  <a href="#ga78977f898a9d53f739c9bf9a1867fd0b">More...</a><br/></td></tr>
<tr class="separator:ga78977f898a9d53f739c9bf9a1867fd0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b277d57793e1212ab0455d47a5fb2ef"><td class="memItemLeft" align="right" valign="top">GSourceHandle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_d_c.html#ga6b277d57793e1212ab0455d47a5fb2ef">gadcHighSpeedGetSource</a> (void)</td></tr>
<tr class="memdesc:ga6b277d57793e1212ab0455d47a5fb2ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on sending results to the GEVENT sub-system.  <a href="#ga6b277d57793e1212ab0455d47a5fb2ef">More...</a><br/></td></tr>
<tr class="separator:ga6b277d57793e1212ab0455d47a5fb2ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43124245b3bbaa16e4f6e7f4339a0239"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_d_c.html#ga43124245b3bbaa16e4f6e7f4339a0239">gadcHighSpeedSetISRCallback</a> (<a class="el" href="group___g_a_d_c.html#ga5bfd47795ea814fcb68c4bd11e81ced9">GADCISRCallbackFunction</a> isrfn)</td></tr>
<tr class="memdesc:ga43124245b3bbaa16e4f6e7f4339a0239"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow retrieving of results from the high speed ADC using an ISR callback.  <a href="#ga43124245b3bbaa16e4f6e7f4339a0239">More...</a><br/></td></tr>
<tr class="separator:ga43124245b3bbaa16e4f6e7f4339a0239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b66dc51441475bbd56cc2575fd87b0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_d_c.html#ga6b66dc51441475bbd56cc2575fd87b0a">gadcHighSpeedSetBSem</a> (<a class="el" href="structgfx_sem.html">gfxSem</a> *pbsem, <a class="el" href="group___g_a_d_c.html#gaf8fd271f26d0327bc4e90ea7b044870b">GEventADC</a> *pEvent)</td></tr>
<tr class="memdesc:ga6b66dc51441475bbd56cc2575fd87b0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow retrieving of results from the high speed ADC using a Binary Semaphore and a static event buffer.  <a href="#ga6b66dc51441475bbd56cc2575fd87b0a">More...</a><br/></td></tr>
<tr class="separator:ga6b66dc51441475bbd56cc2575fd87b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9abbbe4766baae5030952887d81393f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_d_c.html#gaf9abbbe4766baae5030952887d81393f">gadcHighSpeedStart</a> (void)</td></tr>
<tr class="memdesc:gaf9abbbe4766baae5030952887d81393f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the high speed ADC conversions.  <a href="#gaf9abbbe4766baae5030952887d81393f">More...</a><br/></td></tr>
<tr class="separator:gaf9abbbe4766baae5030952887d81393f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c8589721565474bf2adeae2957ce966"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_d_c.html#ga7c8589721565474bf2adeae2957ce966">gadcHighSpeedStop</a> (void)</td></tr>
<tr class="memdesc:ga7c8589721565474bf2adeae2957ce966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the high speed ADC conversions.  <a href="#ga7c8589721565474bf2adeae2957ce966">More...</a><br/></td></tr>
<tr class="separator:ga7c8589721565474bf2adeae2957ce966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a71e8f6a5d66e92824ccf5ccdfb4f3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_d_c.html#ga6a71e8f6a5d66e92824ccf5ccdfb4f3c">gadcLowSpeedGet</a> (uint32_t physdev, adcsample_t *buffer)</td></tr>
<tr class="memdesc:ga6a71e8f6a5d66e92824ccf5ccdfb4f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a single low speed ADC conversion.  <a href="#ga6a71e8f6a5d66e92824ccf5ccdfb4f3c">More...</a><br/></td></tr>
<tr class="separator:ga6a71e8f6a5d66e92824ccf5ccdfb4f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga072e25bf1fc9b176da8b164d5feed119"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___g_o_s.html#ga449976458a084f880dc8e3d29e7eb6f5">bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_d_c.html#ga072e25bf1fc9b176da8b164d5feed119">gadcLowSpeedStart</a> (uint32_t physdev, adcsample_t *buffer, <a class="el" href="group___g_a_d_c.html#ga04a3ae53f590811abf187445215ff820">GADCCallbackFunction</a> fn, void *param)</td></tr>
<tr class="memdesc:ga072e25bf1fc9b176da8b164d5feed119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a low speed ADC conversion with callback (in a thread context)  <a href="#ga072e25bf1fc9b176da8b164d5feed119">More...</a><br/></td></tr>
<tr class="separator:ga072e25bf1fc9b176da8b164d5feed119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8fd271f26d0327bc4e90ea7b044870b"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_g_event_a_d_c__t.html">GEventADC_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_d_c.html#gaf8fd271f26d0327bc4e90ea7b044870b">GEventADC</a></td></tr>
<tr class="memdesc:gaf8fd271f26d0327bc4e90ea7b044870b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The High Speed ADC event structure.  <a href="#gaf8fd271f26d0327bc4e90ea7b044870b">More...</a><br/></td></tr>
<tr class="separator:gaf8fd271f26d0327bc4e90ea7b044870b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
GADC Optional Sizing Parameters</h2></td></tr>
<tr class="memitem:ga3b75b30a27e5afbcdac157b5627dba3b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_d_c.html#ga3b75b30a27e5afbcdac157b5627dba3b">GADC_MAX_HIGH_SPEED_SAMPLERATE</a>&#160;&#160;&#160;44000</td></tr>
<tr class="memdesc:ga3b75b30a27e5afbcdac157b5627dba3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum GADC sample rate.  <a href="#ga3b75b30a27e5afbcdac157b5627dba3b">More...</a><br/></td></tr>
<tr class="separator:ga3b75b30a27e5afbcdac157b5627dba3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga04a3ae53f590811abf187445215ff820"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_d_c.html#ga04a3ae53f590811abf187445215ff820">GADCCallbackFunction</a> )(adcsample_t *buffer, void *param)</td></tr>
<tr class="memdesc:ga04a3ae53f590811abf187445215ff820"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback function (executed in a thread context) for a low speed conversion.  <a href="#ga04a3ae53f590811abf187445215ff820">More...</a><br/></td></tr>
<tr class="separator:ga04a3ae53f590811abf187445215ff820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bfd47795ea814fcb68c4bd11e81ced9"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_d_c.html#ga5bfd47795ea814fcb68c4bd11e81ced9">GADCISRCallbackFunction</a> )(adcsample_t *buffer, <a class="el" href="group___g_o_s.html#gacf18a0d6c4b39d531e021702e9a77984">size_t</a> size)</td></tr>
<tr class="memdesc:ga5bfd47795ea814fcb68c4bd11e81ced9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback function (executed in an ISR context) for a high speed conversion.  <a href="#ga5bfd47795ea814fcb68c4bd11e81ced9">More...</a><br/></td></tr>
<tr class="separator:ga5bfd47795ea814fcb68c4bd11e81ced9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga78977f898a9d53f739c9bf9a1867fd0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gadcHighSpeedInit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>physdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">adcsample_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___g_o_s.html#gacf18a0d6c4b39d531e021702e9a77984">size_t</a>&#160;</td>
          <td class="paramname"><em>bufcount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___g_o_s.html#gacf18a0d6c4b39d531e021702e9a77984">size_t</a>&#160;</td>
          <td class="paramname"><em>samplesPerEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise the high speed ADC. </p>
<p>Initialises but does not start the conversions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">physdev</td><td>A value passed to describe which physical ADC devices/channels to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frequency</td><td>The frequency to create ADC conversions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The static buffer to put the ADC samples into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufcount</td><td>The total number of conversions that will fit in the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">samplesPerEvent</td><td>The number of conversions to do before returning an event.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the high speed ADC is running it will be stopped. The Event subsystem is disconnected from the high speed ADC and any binary semaphore event is forgotten. </dd>
<dd>
bufcount must be greater than countPerEvent (usually 2 or more times) otherwise the buffer will be overwritten with new data while the application is still trying to process the old data. </dd>
<dd>
Due to a bug/feature in Chibi-OS countPerEvent must be even. If bufcount is not evenly divisable by countPerEvent, the remainder must also be even. </dd>
<dd>
The physdev parameter may be used to turn on more than one ADC channel. Each channel is then interleaved into the provided buffer. Note 'bufcount' and 'countPerEvent' parameters describe the number of conversions not the number of samples. As an example, if physdev turns on 2 devices then the buffer contains alternate device samples and the buffer must contain 2 * bufcount samples. The exact meaning of physdev is hardware dependent. </dd>
<dd>
The buffer is circular. When the end of the buffer is reached it will start putting data into the beginning of the buffer again. </dd>
<dd>
The event listener must process the event (and the data in it) before the next event occurs. If not, the following event will be lost. </dd>
<dd>
If bufcount is evenly divisable by countPerEvent, then every event will return countPerEvent conversions. If bufcount is not evenly divisable, it will return a block of samples containing less than countPerEvent samples when it reaches the end of the buffer. </dd>
<dd>
While the high speed ADC is running, low speed conversions can only occur at the frequency of the high speed events. Thus if high speed events are being created at 50Hz (eg countPerEvent = 100, frequency = 5kHz) then the maximum frequency for low speed conversions will be 50Hz.</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6b277d57793e1212ab0455d47a5fb2ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSourceHandle gadcHighSpeedGetSource </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turn on sending results to the GEVENT sub-system. </p>
<p>Returns a GSourceHandle to listen for GEVENT_ADC events.</p>
<dl class="section note"><dt>Note</dt><dd>The high speed ADC will not use the GEVENT system unless this is called first. This saves processing time if the application does not want to use the GEVENT sub-system for the high speed ADC. Once turned on it can only be turned off by calling <code><a class="el" href="group___g_a_d_c.html#ga78977f898a9d53f739c9bf9a1867fd0b" title="Initialise the high speed ADC. ">gadcHighSpeedInit()</a></code> again. </dd>
<dd>
The high speed ADC is capable of signalling via this method, an ISR callback and a binary semaphore at the same time.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The GSourceHandle</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

</div>
</div>
<a class="anchor" id="ga43124245b3bbaa16e4f6e7f4339a0239"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gadcHighSpeedSetISRCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___g_a_d_c.html#ga5bfd47795ea814fcb68c4bd11e81ced9">GADCISRCallbackFunction</a>&#160;</td>
          <td class="paramname"><em>isrfn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allow retrieving of results from the high speed ADC using an ISR callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">isrfn</td><td>The callback function (called in an ISR context).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Passing a NULL for isrfn will turn off signalling via this method as will calling <code><a class="el" href="group___g_a_d_c.html#ga78977f898a9d53f739c9bf9a1867fd0b" title="Initialise the high speed ADC. ">gadcHighSpeedInit()</a></code>. </dd>
<dd>
The high speed ADC is capable of signalling via this method, a binary semaphore and the GEVENT sub-system at the same time.</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6b66dc51441475bbd56cc2575fd87b0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gadcHighSpeedSetBSem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgfx_sem.html">gfxSem</a> *&#160;</td>
          <td class="paramname"><em>pbsem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___g_a_d_c.html#gaf8fd271f26d0327bc4e90ea7b044870b">GEventADC</a> *&#160;</td>
          <td class="paramname"><em>pEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allow retrieving of results from the high speed ADC using a Binary Semaphore and a static event buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pbsem</td><td>The semaphore is signaled when data is available. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pEvent</td><td>The static event buffer to place the result information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Passing a NULL for pbsem or pEvent will turn off signalling via this method as will calling <code><a class="el" href="group___g_a_d_c.html#ga78977f898a9d53f739c9bf9a1867fd0b" title="Initialise the high speed ADC. ">gadcHighSpeedInit()</a></code>. </dd>
<dd>
The high speed ADC is capable of signalling via this method, an ISR callback and the GEVENT sub-system at the same time.</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf9abbbe4766baae5030952887d81393f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gadcHighSpeedStart </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start the high speed ADC conversions. </p>
<dl class="section pre"><dt>Precondition</dt><dd>It must have been initialised first with <code><a class="el" href="group___g_a_d_c.html#ga78977f898a9d53f739c9bf9a1867fd0b" title="Initialise the high speed ADC. ">gadcHighSpeedInit()</a></code> </dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7c8589721565474bf2adeae2957ce966"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gadcHighSpeedStop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop the high speed ADC conversions. </p>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6a71e8f6a5d66e92824ccf5ccdfb4f3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gadcLowSpeedGet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>physdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">adcsample_t *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a single low speed ADC conversion. </p>
<p>Blocks until the conversion is complete </p>
<dl class="section pre"><dt>Precondition</dt><dd>This should not be called from within a GTimer callback as this routine blocks until the conversion is ready.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">physdev</td><td>A value passed to describe which physical ADC devices/channels to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The static buffer to put the ADC samples into.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This may take a while to complete if the high speed ADC is running as the conversion is interleaved with the high speed ADC conversions on a buffer completion. </dd>
<dd>
The result buffer must be large enough to store one sample per device described by the 'physdev' parameter. </dd>
<dd>
If calling this routine would exceed <code>GADC_MAX_LOWSPEED_DEVICES</code> simultaneous low speed devices, the routine will wait for an available slot to complete the conversion. </dd>
<dd>
Specifying more than one device in physdev is possible but discouraged as the calculations to ensure the high speed ADC correctness will be incorrect. Symptoms from over-running the high speed ADC include high speed samples being lost.</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

</div>
</div>
<a class="anchor" id="ga072e25bf1fc9b176da8b164d5feed119"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___g_o_s.html#ga449976458a084f880dc8e3d29e7eb6f5">bool_t</a> gadcLowSpeedStart </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>physdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">adcsample_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___g_a_d_c.html#ga04a3ae53f590811abf187445215ff820">GADCCallbackFunction</a>&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a low speed ADC conversion with callback (in a thread context) </p>
<p>Returns FALSE if there are no free low speed ADC slots. See <code>GADC_MAX_LOWSPEED_DEVICES</code> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">physdev</td><td>A value passed to describe which physical ADC devices/channels to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The static buffer to put the ADC samples into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fn</td><td>The callback function to call when the conversion is complete. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>A parameter to pass to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FALSE if no free low speed ADC slots.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This may be safely called from within a GTimer callback. </dd>
<dd>
The callback may take a while to occur if the high speed ADC is running as the conversion is interleaved with the high speed ADC conversions on a buffer completion. </dd>
<dd>
The result buffer must be large enough to store one sample per device described by the 'physdev' parameter. </dd>
<dd>
As this routine uses a low speed ADC, it asserts if you try to run more than <code>GADC_MAX_LOWSPEED_DEVICES</code> at the same time. </dd>
<dd>
Specifying more than one device in physdev is possible but discouraged as the calculations to ensure the high speed ADC correctness will be incorrect. Symptoms from over-running the high speed ADC include high speed samples being lost.</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga3b75b30a27e5afbcdac157b5627dba3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GADC_MAX_HIGH_SPEED_SAMPLERATE&#160;&#160;&#160;44000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum GADC sample rate. </p>
<p>Defaults to 44000 </p>
<dl class="section note"><dt>Note</dt><dd>This value must be less than half the maximum sample rate allowed by the CPU. This is to ensure there is time between high speed samples to perform low speed device sampling. </dd></dl>

<p>Definition at line <a class="el" href="gadc_2options_8h_source.html#l00037">37</a> of file <a class="el" href="gadc_2options_8h_source.html">gadc/options.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gaf8fd271f26d0327bc4e90ea7b044870b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_g_event_a_d_c__t.html">GEventADC_t</a>  <a class="el" href="group___g_a_d_c.html#gaf8fd271f26d0327bc4e90ea7b044870b">GEventADC</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The High Speed ADC event structure. </p>

</div>
</div>
<a class="anchor" id="ga04a3ae53f590811abf187445215ff820"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* GADCCallbackFunction)(adcsample_t *buffer, void *param)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A callback function (executed in a thread context) for a low speed conversion. </p>

<p>Definition at line <a class="el" href="gadc_8h_source.html#l00091">91</a> of file <a class="el" href="gadc_8h_source.html">gadc.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga5bfd47795ea814fcb68c4bd11e81ced9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* GADCISRCallbackFunction)(adcsample_t *buffer, <a class="el" href="group___g_o_s.html#gacf18a0d6c4b39d531e021702e9a77984">size_t</a> size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A callback function (executed in an ISR context) for a high speed conversion. </p>

<p>Definition at line <a class="el" href="gadc_8h_source.html#l00096">96</a> of file <a class="el" href="gadc_8h_source.html">gadc.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sun Nov 10 2013 23:06:13 for uGFX by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
