<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>uGFX: GQUEUE</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">uGFX
   &#160;<span id="projectnumber">2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___g_q_u_e_u_e.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a>  </div>
  <div class="headertitle">
<div class="title">GQUEUE</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Module which provides queue management (only internally used) </p>
<p>There are 3 types of queues: </p>
<ul>
<li>
<b>Asynchronous Queues (ASync) </b> - Queue operations never block </li>
<li>
<b>Get Synchronous Queues (GSync) </b> - Queue Get operations block until something is placed in the Queue </li>
<li>
<b>Put Synchronous Queues (PSync)</b> - Queue Put operations block until the element is removed from the Queue </li>
<li>
<b>Fully Synchronous Queues (FSync)</b> - Queue GET and Put operations block </li>
</ul>
<p>We need 4 types of queues even though fully synchronous queues support all operations including asynchronous operations because fully synchronous queues have the highest storage requirements. The other queue types are optimizations. Efficiency IS important to use (particularly RAM efficiency). In practice we only implement ASync, GSync and FSync queues as PSync queues are of dubious value. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A queue.  <a href="structgfx_queue_a_sync.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A queue item.  <a href="structgfx_queue_a_sync_item.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0274bbb59822547a490bcc8331ba7f1a"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_q_u_e_u_e.html#ga0274bbb59822547a490bcc8331ba7f1a">gfxQueueASync</a></td></tr>
<tr class="memdesc:ga0274bbb59822547a490bcc8331ba7f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A queue.  <a href="#ga0274bbb59822547a490bcc8331ba7f1a">More...</a><br/></td></tr>
<tr class="separator:ga0274bbb59822547a490bcc8331ba7f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae485b5c37fcf8e479764e92c7e599902"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_q_u_e_u_e.html#gae485b5c37fcf8e479764e92c7e599902">gfxQueueASyncItem</a></td></tr>
<tr class="memdesc:gae485b5c37fcf8e479764e92c7e599902"><td class="mdescLeft">&#160;</td><td class="mdescRight">A queue item.  <a href="#gae485b5c37fcf8e479764e92c7e599902">More...</a><br/></td></tr>
<tr class="separator:gae485b5c37fcf8e479764e92c7e599902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03a187ba5739f36530498f333145a913"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_q_u_e_u_e.html#ga03a187ba5739f36530498f333145a913">gfxQueueASyncInit</a> (<a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a> *pqueue)</td></tr>
<tr class="memdesc:ga03a187ba5739f36530498f333145a913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a queue.  <a href="#ga03a187ba5739f36530498f333145a913">More...</a><br/></td></tr>
<tr class="separator:ga03a187ba5739f36530498f333145a913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83033845f1cc4e859293f759d184ef24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_q_u_e_u_e.html#ga83033845f1cc4e859293f759d184ef24">gfxQueueASyncGet</a> (<a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a> *pqueue)</td></tr>
<tr class="memdesc:ga83033845f1cc4e859293f759d184ef24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an item from the head of the queue (and remove it from the queue).  <a href="#ga83033845f1cc4e859293f759d184ef24">More...</a><br/></td></tr>
<tr class="separator:ga83033845f1cc4e859293f759d184ef24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga001f294beec7a5a93bb386caded77b17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_q_u_e_u_e.html#ga001f294beec7a5a93bb386caded77b17">gfxQueueASyncPut</a> (<a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a> *pqueue, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *pitem)</td></tr>
<tr class="memdesc:ga001f294beec7a5a93bb386caded77b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put an item on the end of the queue.  <a href="#ga001f294beec7a5a93bb386caded77b17">More...</a><br/></td></tr>
<tr class="separator:ga001f294beec7a5a93bb386caded77b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee90fcbacaf0ac34a161757c6652e7fa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_q_u_e_u_e.html#gaee90fcbacaf0ac34a161757c6652e7fa">gfxQueueASyncPop</a>(pqueue)&#160;&#160;&#160;<a class="el" href="group___g_q_u_e_u_e.html#ga83033845f1cc4e859293f759d184ef24">gfxQueueASyncGet</a>(pqueue)</td></tr>
<tr class="memdesc:gaee90fcbacaf0ac34a161757c6652e7fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop an item from the head of the queue (and remove it from the queue).  <a href="#gaee90fcbacaf0ac34a161757c6652e7fa">More...</a><br/></td></tr>
<tr class="separator:gaee90fcbacaf0ac34a161757c6652e7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89673f2d1210c10ff00ef6c4b5312900"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_q_u_e_u_e.html#ga89673f2d1210c10ff00ef6c4b5312900">gfxQueueASyncPush</a> (<a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a> *pqueue, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *pitem)</td></tr>
<tr class="memdesc:ga89673f2d1210c10ff00ef6c4b5312900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push an item into the start of the queue.  <a href="#ga89673f2d1210c10ff00ef6c4b5312900">More...</a><br/></td></tr>
<tr class="separator:ga89673f2d1210c10ff00ef6c4b5312900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacab8013b870b58e1a8a082fac8d06e1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_q_u_e_u_e.html#gacab8013b870b58e1a8a082fac8d06e1d">gfxQueueASyncRemove</a> (<a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a> *pqueue, <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *pitem)</td></tr>
<tr class="memdesc:gacab8013b870b58e1a8a082fac8d06e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an item from the queue.  <a href="#gacab8013b870b58e1a8a082fac8d06e1d">More...</a><br/></td></tr>
<tr class="separator:gacab8013b870b58e1a8a082fac8d06e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae50dbbdc8f63575113f9a8e171fbb0a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___g_o_s.html#ga449976458a084f880dc8e3d29e7eb6f5">bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_q_u_e_u_e.html#gae50dbbdc8f63575113f9a8e171fbb0a8">gfxQueueASyncIsEmpty</a> (<a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a> *pqueue)</td></tr>
<tr class="memdesc:gae50dbbdc8f63575113f9a8e171fbb0a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the queue empty?  <a href="#gae50dbbdc8f63575113f9a8e171fbb0a8">More...</a><br/></td></tr>
<tr class="separator:gae50dbbdc8f63575113f9a8e171fbb0a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5402e7c7e959c59230bdc2650366089"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___g_o_s.html#ga449976458a084f880dc8e3d29e7eb6f5">bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_q_u_e_u_e.html#gae5402e7c7e959c59230bdc2650366089">gfxQueueASyncIsIn</a> (<a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a> *pqueue, const <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *pitem)</td></tr>
<tr class="memdesc:gae5402e7c7e959c59230bdc2650366089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is an item in the queue?  <a href="#gae5402e7c7e959c59230bdc2650366089">More...</a><br/></td></tr>
<tr class="separator:gae5402e7c7e959c59230bdc2650366089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9b14a9595a6fde52bf315aae064a446"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_q_u_e_u_e.html#gae9b14a9595a6fde52bf315aae064a446">gfxQueueASyncPeek</a>(pqueue)&#160;&#160;&#160;((const <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *)((pqueue)-&gt;head))</td></tr>
<tr class="memdesc:gae9b14a9595a6fde52bf315aae064a446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first item from the head of the queue but do not remove it from the queue.  <a href="#gae9b14a9595a6fde52bf315aae064a446">More...</a><br/></td></tr>
<tr class="separator:gae9b14a9595a6fde52bf315aae064a446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d88bd563a6b22d593622d8e3a6f636b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_q_u_e_u_e.html#ga0d88bd563a6b22d593622d8e3a6f636b">gfxQueueASyncNext</a>(pitem)&#160;&#160;&#160;((const <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *)((pitem)-&gt;next))</td></tr>
<tr class="memdesc:ga0d88bd563a6b22d593622d8e3a6f636b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next item in the queue (but do not remove it from the queue).  <a href="#ga0d88bd563a6b22d593622d8e3a6f636b">More...</a><br/></td></tr>
<tr class="separator:ga0d88bd563a6b22d593622d8e3a6f636b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
GQUEUE Functions to include.</h2></td></tr>
<tr class="memitem:ga1833961a3b42ae3f87255b9c4c1c3737"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_q_u_e_u_e.html#ga1833961a3b42ae3f87255b9c4c1c3737">GQUEUE_NEED_ASYNC</a>&#160;&#160;&#160;<a class="el" href="gos_8h.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a></td></tr>
<tr class="memdesc:ga1833961a3b42ae3f87255b9c4c1c3737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable Asynchronous Queues.  <a href="#ga1833961a3b42ae3f87255b9c4c1c3737">More...</a><br/></td></tr>
<tr class="separator:ga1833961a3b42ae3f87255b9c4c1c3737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b5470bf32fe076ae47955b835bac6fc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_q_u_e_u_e.html#ga3b5470bf32fe076ae47955b835bac6fc">GQUEUE_NEED_GSYNC</a>&#160;&#160;&#160;<a class="el" href="gos_8h.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a></td></tr>
<tr class="memdesc:ga3b5470bf32fe076ae47955b835bac6fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable Get-Synchronous Queues.  <a href="#ga3b5470bf32fe076ae47955b835bac6fc">More...</a><br/></td></tr>
<tr class="separator:ga3b5470bf32fe076ae47955b835bac6fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb6bbd123f626768795f0d80a2a6d47f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_q_u_e_u_e.html#gaeb6bbd123f626768795f0d80a2a6d47f">GQUEUE_NEED_FSYNC</a>&#160;&#160;&#160;<a class="el" href="gos_8h.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a></td></tr>
<tr class="memdesc:gaeb6bbd123f626768795f0d80a2a6d47f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable Fully Synchronous Queues.  <a href="#gaeb6bbd123f626768795f0d80a2a6d47f">More...</a><br/></td></tr>
<tr class="separator:gaeb6bbd123f626768795f0d80a2a6d47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga03a187ba5739f36530498f333145a913"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfxQueueASyncInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a> *&#160;</td>
          <td class="paramname"><em>pqueue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise a queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pqueue</td><td>A pointer to the queue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Whilst queues are normally FIFO, a GFX queue also supports push and pop operations. A pop operation is the same as normal get from the queue but a push places the item at the head of the queue instead of the tail (as a put would).</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

</div>
</div>
<a class="anchor" id="ga83033845f1cc4e859293f759d184ef24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a>* gfxQueueASyncGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a> *&#160;</td>
          <td class="paramname"><em>pqueue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an item from the head of the queue (and remove it from the queue). </p>
<dl class="section return"><dt>Returns</dt><dd>NULL if the timeout expires before an item is available</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pqueue</td><td>A pointer to the queue </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ms</td><td>The maxmimum time to wait for an item. For ASync queues this parameter is not specified as TIME_IMMEDIATE is assumed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

</div>
</div>
<a class="anchor" id="ga001f294beec7a5a93bb386caded77b17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfxQueueASyncPut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a> *&#160;</td>
          <td class="paramname"><em>pqueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *&#160;</td>
          <td class="paramname"><em>pitem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put an item on the end of the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>none for ASync and GSync queues; For FSync queues - FALSE on timeout, otherwise TRUE</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pqueue</td><td>A pointer to the queue </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pitem</td><td>A pointer to the queue item </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ms</td><td>The maxmimum time to wait for an item to be removed from the queue (only for FSync queues)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>FSync: Use a delay time of TIME_IMMEDIATE if you don't want to wait until the item is removed from the queue. Note that even if the timeout occurs - the item remains in the queue.</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

</div>
</div>
<a class="anchor" id="ga89673f2d1210c10ff00ef6c4b5312900"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfxQueueASyncPush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a> *&#160;</td>
          <td class="paramname"><em>pqueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *&#160;</td>
          <td class="paramname"><em>pitem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push an item into the start of the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>none for ASync and GSync queues; For FSync queues - FALSE on timeout, otherwise TRUE</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pqueue</td><td>A pointer to the queue </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pitem</td><td>A pointer to the queue item </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ms</td><td>The maxmimum time to wait for an item to be popped (only for FSync queues)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>FSync: Use a delay time of TIME_IMMEDIATE if you don't want to wait until the item is removed from the queue. Note that even if the timeout occurs - the item remains in the queue.</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

</div>
</div>
<a class="anchor" id="gacab8013b870b58e1a8a082fac8d06e1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfxQueueASyncRemove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a> *&#160;</td>
          <td class="paramname"><em>pqueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *&#160;</td>
          <td class="paramname"><em>pitem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an item from the queue. </p>
<dl class="section note"><dt>Note</dt><dd>Removes the specified item from the queue where-ever it is in the queue</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pqueue</td><td>A pointer to the queue </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pitem</td><td>A pointer to the queue item</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the item isn't in the queue the routine just returns. </dd>
<dd>
If a process is waiting on the Put/Push operation for the item, that process will be signaled.</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

</div>
</div>
<a class="anchor" id="gae50dbbdc8f63575113f9a8e171fbb0a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___g_o_s.html#ga449976458a084f880dc8e3d29e7eb6f5">bool_t</a> gfxQueueASyncIsEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a> *&#160;</td>
          <td class="paramname"><em>pqueue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the queue empty? </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the queue is empty</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pqueue</td><td>A pointer to the queue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

</div>
</div>
<a class="anchor" id="gae5402e7c7e959c59230bdc2650366089"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___g_o_s.html#ga449976458a084f880dc8e3d29e7eb6f5">bool_t</a> gfxQueueASyncIsIn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a> *&#160;</td>
          <td class="paramname"><em>pqueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *&#160;</td>
          <td class="paramname"><em>pitem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is an item in the queue? </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the item is in the queue?</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pqueue</td><td>A pointer to the queue </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pitem</td><td>A pointer to the queue item</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This operation may be expensive.</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gaee90fcbacaf0ac34a161757c6652e7fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define gfxQueueASyncPop</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pqueue</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group___g_q_u_e_u_e.html#ga83033845f1cc4e859293f759d184ef24">gfxQueueASyncGet</a>(pqueue)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pop an item from the head of the queue (and remove it from the queue). </p>
<p>This is exactly the same as the Get operation above.</p>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

<p>Definition at line <a class="el" href="gqueue_8h_source.html#l00139">139</a> of file <a class="el" href="gqueue_8h_source.html">gqueue.h</a>.</p>

</div>
</div>
<a class="anchor" id="gae9b14a9595a6fde52bf315aae064a446"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define gfxQueueASyncPeek</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pqueue</td><td>)</td>
          <td>&#160;&#160;&#160;((const <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *)((pqueue)-&gt;head))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the first item from the head of the queue but do not remove it from the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>NULL if no item is available.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pqueue</td><td>A pointer to the queue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This call does not block. </dd>
<dd>
This can be used as the first call to iterate all the elements in the queue. </dd>
<dd>
As that item is still on the queue, it should be treated as read-only. It could also be removed from the queue at any time by another thread (thereby altering the queue item).</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

<p>Definition at line <a class="el" href="gqueue_8h_source.html#l00229">229</a> of file <a class="el" href="gqueue_8h_source.html">gqueue.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga0d88bd563a6b22d593622d8e3a6f636b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define gfxQueueASyncNext</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pitem</td><td>)</td>
          <td>&#160;&#160;&#160;((const <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a> *)((pitem)-&gt;next))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next item in the queue (but do not remove it from the queue). </p>
<dl class="section return"><dt>Returns</dt><dd>NULL if no item is available.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pitem</td><td>The previous item in the queue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This call does not block. </dd>
<dd>
This can be used as subsequent calls to iterate all the elements in the queue. </dd>
<dd>
As that item is still on the queue, it should be treated as read-only. It could also be removed from the queue at any time by another thread (thereby altering the queue item).</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

<p>Definition at line <a class="el" href="gqueue_8h_source.html#l00249">249</a> of file <a class="el" href="gqueue_8h_source.html">gqueue.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga1833961a3b42ae3f87255b9c4c1c3737"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GQUEUE_NEED_ASYNC&#160;&#160;&#160;<a class="el" href="gos_8h.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable Asynchronous Queues. </p>
<p>Defaults to FALSE </p>

<p>Definition at line <a class="el" href="gqueue_2options_8h_source.html#l00028">28</a> of file <a class="el" href="gqueue_2options_8h_source.html">gqueue/options.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga3b5470bf32fe076ae47955b835bac6fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GQUEUE_NEED_GSYNC&#160;&#160;&#160;<a class="el" href="gos_8h.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable Get-Synchronous Queues. </p>
<p>Defaults to FALSE </p>

<p>Definition at line <a class="el" href="gqueue_2options_8h_source.html#l00035">35</a> of file <a class="el" href="gqueue_2options_8h_source.html">gqueue/options.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaeb6bbd123f626768795f0d80a2a6d47f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GQUEUE_NEED_FSYNC&#160;&#160;&#160;<a class="el" href="gos_8h.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable Fully Synchronous Queues. </p>
<p>Defaults to FALSE </p>

<p>Definition at line <a class="el" href="gqueue_2options_8h_source.html#l00042">42</a> of file <a class="el" href="gqueue_2options_8h_source.html">gqueue/options.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga0274bbb59822547a490bcc8331ba7f1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a>  <a class="el" href="structgfx_queue_a_sync.html">gfxQueueASync</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A queue. </p>

</div>
</div>
<a class="anchor" id="gae485b5c37fcf8e479764e92c7e599902"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a>  <a class="el" href="structgfx_queue_a_sync_item.html">gfxQueueASyncItem</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A queue item. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sun Nov 10 2013 23:06:13 for uGFX by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
