<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>uGFX: gos.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">uGFX
   &#160;<span id="projectnumber">2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('gos_8h.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">gos.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>GOS - Operating System Support header file. </p>

<p>Definition in file <a class="el" href="gos_8h_source.html">gos.h</a>.</p>
</div>
<p><a href="gos_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgfx_sem.html">gfxSem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A semaphore.  <a href="structgfx_sem.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgfx_mutex.html">gfxMutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutex.  <a href="structgfx_mutex.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad737a9b29b047ee24953a1f367d7501a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gos_8h.html#ad737a9b29b047ee24953a1f367d7501a">gfxHalt</a> (const char *msg)</td></tr>
<tr class="memdesc:ad737a9b29b047ee24953a1f367d7501a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Halt the GFX application due to an error.  <a href="#ad737a9b29b047ee24953a1f367d7501a">More...</a><br/></td></tr>
<tr class="separator:ad737a9b29b047ee24953a1f367d7501a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa446ccfdfdd4c575e648956ae96f2a3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gos_8h.html#aa446ccfdfdd4c575e648956ae96f2a3b">gfxExit</a> (void)</td></tr>
<tr class="memdesc:aa446ccfdfdd4c575e648956ae96f2a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit the GFX application.  <a href="#aa446ccfdfdd4c575e648956ae96f2a3b">More...</a><br/></td></tr>
<tr class="separator:aa446ccfdfdd4c575e648956ae96f2a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7009723240f48524fdea5d18b63966c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gos_8h.html#ab7009723240f48524fdea5d18b63966c">gfxAlloc</a> (<a class="el" href="group___g_o_s.html#gacf18a0d6c4b39d531e021702e9a77984">size_t</a> sz)</td></tr>
<tr class="memdesc:ab7009723240f48524fdea5d18b63966c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory.  <a href="#ab7009723240f48524fdea5d18b63966c">More...</a><br/></td></tr>
<tr class="separator:ab7009723240f48524fdea5d18b63966c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d499dfdb43e7a4e19c6f00c7f0d51c9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gos_8h.html#a7d499dfdb43e7a4e19c6f00c7f0d51c9">gfxRealloc</a> (void *ptr, <a class="el" href="group___g_o_s.html#gacf18a0d6c4b39d531e021702e9a77984">size_t</a> oldsz, <a class="el" href="group___g_o_s.html#gacf18a0d6c4b39d531e021702e9a77984">size_t</a> newsz)</td></tr>
<tr class="memdesc:a7d499dfdb43e7a4e19c6f00c7f0d51c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-allocate memory.  <a href="#a7d499dfdb43e7a4e19c6f00c7f0d51c9">More...</a><br/></td></tr>
<tr class="separator:a7d499dfdb43e7a4e19c6f00c7f0d51c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35da30b7a140abbaa7892d8a1fc0b78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gos_8h.html#ae35da30b7a140abbaa7892d8a1fc0b78">gfxFree</a> (void *ptr)</td></tr>
<tr class="memdesc:ae35da30b7a140abbaa7892d8a1fc0b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free memory.  <a href="#ae35da30b7a140abbaa7892d8a1fc0b78">More...</a><br/></td></tr>
<tr class="separator:ae35da30b7a140abbaa7892d8a1fc0b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e13e354721ffac812c59d360956556"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gos_8h.html#a48e13e354721ffac812c59d360956556">gfxYield</a> (void)</td></tr>
<tr class="memdesc:a48e13e354721ffac812c59d360956556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yield the current thread.  <a href="#a48e13e354721ffac812c59d360956556">More...</a><br/></td></tr>
<tr class="separator:a48e13e354721ffac812c59d360956556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c25311a0069cb77efef056190c6adb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gos_8h.html#a9c25311a0069cb77efef056190c6adb4">gfxSleepMilliseconds</a> (delaytime_t ms)</td></tr>
<tr class="memdesc:a9c25311a0069cb77efef056190c6adb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the current thread to sleep for the specified period in milliseconds.  <a href="#a9c25311a0069cb77efef056190c6adb4">More...</a><br/></td></tr>
<tr class="separator:a9c25311a0069cb77efef056190c6adb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0924aee637981f2be6752f6c6bebd1bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gos_8h.html#a0924aee637981f2be6752f6c6bebd1bf">gfxSleepMicroseconds</a> (delaytime_t ms)</td></tr>
<tr class="memdesc:a0924aee637981f2be6752f6c6bebd1bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the current thread to sleep for the specified period in microseconds.  <a href="#a0924aee637981f2be6752f6c6bebd1bf">More...</a><br/></td></tr>
<tr class="separator:a0924aee637981f2be6752f6c6bebd1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19830585f588833a50c6e8c81f32bc23"><td class="memItemLeft" align="right" valign="top">systemticks_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gos_8h.html#a19830585f588833a50c6e8c81f32bc23">gfxSystemTicks</a> (void)</td></tr>
<tr class="memdesc:a19830585f588833a50c6e8c81f32bc23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current operating system tick time.  <a href="#a19830585f588833a50c6e8c81f32bc23">More...</a><br/></td></tr>
<tr class="separator:a19830585f588833a50c6e8c81f32bc23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d570620c96ea96590535f6e91a2c50"><td class="memItemLeft" align="right" valign="top">systemticks_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gos_8h.html#a41d570620c96ea96590535f6e91a2c50">gfxMillisecondsToTicks</a> (delaytime_t ms)</td></tr>
<tr class="memdesc:a41d570620c96ea96590535f6e91a2c50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a given number of millseconds to a number of operating system ticks.  <a href="#a41d570620c96ea96590535f6e91a2c50">More...</a><br/></td></tr>
<tr class="separator:a41d570620c96ea96590535f6e91a2c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc20160d9f65e7e3d506f725123b2db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gos_8h.html#aacc20160d9f65e7e3d506f725123b2db">gfxSystemLock</a> (void)</td></tr>
<tr class="memdesc:aacc20160d9f65e7e3d506f725123b2db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the operating system to protect a sequence of code.  <a href="#aacc20160d9f65e7e3d506f725123b2db">More...</a><br/></td></tr>
<tr class="separator:aacc20160d9f65e7e3d506f725123b2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa59c0143ca45eac02a21fdb67b75e4e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gos_8h.html#aa59c0143ca45eac02a21fdb67b75e4e0">gfxSystemUnlock</a> (void)</td></tr>
<tr class="memdesc:aa59c0143ca45eac02a21fdb67b75e4e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the operating system previous locked by <a class="el" href="gos_8h.html#aacc20160d9f65e7e3d506f725123b2db" title="Lock the operating system to protect a sequence of code. ">gfxSystemLock()</a>  <a href="#aa59c0143ca45eac02a21fdb67b75e4e0">More...</a><br/></td></tr>
<tr class="separator:aa59c0143ca45eac02a21fdb67b75e4e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca36f9a37de74f155ae66a544ec6ea2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gos_8h.html#a2ca36f9a37de74f155ae66a544ec6ea2">gfxMutexInit</a> (<a class="el" href="structgfx_mutex.html">gfxMutex</a> *pmutex)</td></tr>
<tr class="memdesc:a2ca36f9a37de74f155ae66a544ec6ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a mutex to protect a region of code from other threads.  <a href="#a2ca36f9a37de74f155ae66a544ec6ea2">More...</a><br/></td></tr>
<tr class="separator:a2ca36f9a37de74f155ae66a544ec6ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1103102fd5edd1687f9ba6253279dec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gos_8h.html#ab1103102fd5edd1687f9ba6253279dec">gfxMutexDestroy</a> (<a class="el" href="structgfx_mutex.html">gfxMutex</a> *pmutex)</td></tr>
<tr class="memdesc:ab1103102fd5edd1687f9ba6253279dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a Mutex.  <a href="#ab1103102fd5edd1687f9ba6253279dec">More...</a><br/></td></tr>
<tr class="separator:ab1103102fd5edd1687f9ba6253279dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64bf76af754056cb06ec673944203350"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gos_8h.html#a64bf76af754056cb06ec673944203350">gfxMutexEnter</a> (<a class="el" href="structgfx_mutex.html">gfxMutex</a> *pmutex)</td></tr>
<tr class="memdesc:a64bf76af754056cb06ec673944203350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enter the critical code region protected by the mutex.  <a href="#a64bf76af754056cb06ec673944203350">More...</a><br/></td></tr>
<tr class="separator:a64bf76af754056cb06ec673944203350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ca335a027a51d07559e2740b22518b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gos_8h.html#a39ca335a027a51d07559e2740b22518b">gfxMutexExit</a> (<a class="el" href="structgfx_mutex.html">gfxMutex</a> *pmutex)</td></tr>
<tr class="memdesc:a39ca335a027a51d07559e2740b22518b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit the critical code region protected by the mutex.  <a href="#a39ca335a027a51d07559e2740b22518b">More...</a><br/></td></tr>
<tr class="separator:a39ca335a027a51d07559e2740b22518b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeebc0d40e24efc49855ec4d9291cd047"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gos_8h.html#aeebc0d40e24efc49855ec4d9291cd047">gfxSemInit</a> (<a class="el" href="structgfx_sem.html">gfxSem</a> *psem, semcount_t val, semcount_t limit)</td></tr>
<tr class="memdesc:aeebc0d40e24efc49855ec4d9291cd047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a Counted Semaphore.  <a href="#aeebc0d40e24efc49855ec4d9291cd047">More...</a><br/></td></tr>
<tr class="separator:aeebc0d40e24efc49855ec4d9291cd047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f87a78e68239626d2adb5851d532c24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gos_8h.html#a2f87a78e68239626d2adb5851d532c24">gfxSemDestroy</a> (<a class="el" href="structgfx_sem.html">gfxSem</a> *psem)</td></tr>
<tr class="memdesc:a2f87a78e68239626d2adb5851d532c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a Counted Semaphore.  <a href="#a2f87a78e68239626d2adb5851d532c24">More...</a><br/></td></tr>
<tr class="separator:a2f87a78e68239626d2adb5851d532c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d1b2e8df8c9d69ddc4df6df650563a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___g_o_s.html#ga449976458a084f880dc8e3d29e7eb6f5">bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gos_8h.html#ac3d1b2e8df8c9d69ddc4df6df650563a">gfxSemWait</a> (<a class="el" href="structgfx_sem.html">gfxSem</a> *psem, delaytime_t ms)</td></tr>
<tr class="memdesc:ac3d1b2e8df8c9d69ddc4df6df650563a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait on a semaphore.  <a href="#ac3d1b2e8df8c9d69ddc4df6df650563a">More...</a><br/></td></tr>
<tr class="separator:ac3d1b2e8df8c9d69ddc4df6df650563a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaedf65e9e766d053a2a9cd947f190743"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gos_8h.html#aaedf65e9e766d053a2a9cd947f190743">gfxSemSignal</a> (<a class="el" href="structgfx_sem.html">gfxSem</a> *psem)</td></tr>
<tr class="memdesc:aaedf65e9e766d053a2a9cd947f190743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal a semaphore.  <a href="#aaedf65e9e766d053a2a9cd947f190743">More...</a><br/></td></tr>
<tr class="separator:aaedf65e9e766d053a2a9cd947f190743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f475f56ff6a38027c73c2dd17889b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gos_8h.html#a68f475f56ff6a38027c73c2dd17889b4">gfxSemSignalI</a> (<a class="el" href="structgfx_sem.html">gfxSem</a> *psem)</td></tr>
<tr class="memdesc:a68f475f56ff6a38027c73c2dd17889b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal a semaphore.  <a href="#a68f475f56ff6a38027c73c2dd17889b4">More...</a><br/></td></tr>
<tr class="separator:a68f475f56ff6a38027c73c2dd17889b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c9c471ce112d0a9210a5e84d996aca7"><td class="memItemLeft" align="right" valign="top">semcount_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gos_8h.html#a2c9c471ce112d0a9210a5e84d996aca7">gfxSemCounter</a> (<a class="el" href="structgfx_sem.html">gfxSem</a> *psem)</td></tr>
<tr class="memdesc:a2c9c471ce112d0a9210a5e84d996aca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current semaphore count.  <a href="#a2c9c471ce112d0a9210a5e84d996aca7">More...</a><br/></td></tr>
<tr class="separator:a2c9c471ce112d0a9210a5e84d996aca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f423c871e3daebd5db78b5e74e431fc"><td class="memItemLeft" align="right" valign="top">semcount_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gos_8h.html#a8f423c871e3daebd5db78b5e74e431fc">gfxSemCounterI</a> (<a class="el" href="structgfx_sem.html">gfxSem</a> *psem)</td></tr>
<tr class="memdesc:a8f423c871e3daebd5db78b5e74e431fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current semaphore count.  <a href="#a8f423c871e3daebd5db78b5e74e431fc">More...</a><br/></td></tr>
<tr class="separator:a8f423c871e3daebd5db78b5e74e431fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5bfa81d284cf05bceaa54094e14377"><td class="memItemLeft" align="right" valign="top"><a class="el" href="gos_8h.html#a642ee21944f2c0f3e122cd20c272e2b3">gfxThreadHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gos_8h.html#aee5bfa81d284cf05bceaa54094e14377">gfxThreadCreate</a> (void *stackarea, <a class="el" href="group___g_o_s.html#gacf18a0d6c4b39d531e021702e9a77984">size_t</a> stacksz, threadpriority_t prio, <a class="el" href="group___g_o_s.html#gad64db2ca4caafeffec7b5cc14d56806a">DECLARE_THREAD_FUNCTION</a>((*fn), p), void *param)</td></tr>
<tr class="memdesc:aee5bfa81d284cf05bceaa54094e14377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a new thread.  <a href="#aee5bfa81d284cf05bceaa54094e14377">More...</a><br/></td></tr>
<tr class="separator:aee5bfa81d284cf05bceaa54094e14377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83eafa3bb719227aaa2cdff9b0657354"><td class="memItemLeft" align="right" valign="top">threadreturn_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gos_8h.html#a83eafa3bb719227aaa2cdff9b0657354">gfxThreadWait</a> (<a class="el" href="gos_8h.html#a642ee21944f2c0f3e122cd20c272e2b3">gfxThreadHandle</a> thread)</td></tr>
<tr class="memdesc:a83eafa3bb719227aaa2cdff9b0657354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a thread to finish.  <a href="#a83eafa3bb719227aaa2cdff9b0657354">More...</a><br/></td></tr>
<tr class="separator:a83eafa3bb719227aaa2cdff9b0657354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d56c2744416cf21919a28ecedc79ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="gos_8h.html#a642ee21944f2c0f3e122cd20c272e2b3">gfxThreadHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gos_8h.html#a21d56c2744416cf21919a28ecedc79ae">gfxThreadMe</a> (void)</td></tr>
<tr class="memdesc:a21d56c2744416cf21919a28ecedc79ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current thread handle.  <a href="#a21d56c2744416cf21919a28ecedc79ae">More...</a><br/></td></tr>
<tr class="separator:a21d56c2744416cf21919a28ecedc79ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3537b26f39e3389827635dcf370ab134"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gos_8h.html#a3537b26f39e3389827635dcf370ab134">gfxThreadClose</a> (<a class="el" href="gos_8h.html#a642ee21944f2c0f3e122cd20c272e2b3">gfxThreadHandle</a> thread)</td></tr>
<tr class="memdesc:a3537b26f39e3389827635dcf370ab134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the thread handle.  <a href="#a3537b26f39e3389827635dcf370ab134">More...</a><br/></td></tr>
<tr class="separator:a3537b26f39e3389827635dcf370ab134"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa93f0eb578d23995850d61f7d61c55c1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gos_8h.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:aa93f0eb578d23995850d61f7d61c55c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various platform (and operating system) constants.  <a href="#aa93f0eb578d23995850d61f7d61c55c1">More...</a><br/></td></tr>
<tr class="separator:aa93f0eb578d23995850d61f7d61c55c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a642ee21944f2c0f3e122cd20c272e2b3"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="gos_8h.html#a642ee21944f2c0f3e122cd20c272e2b3">gfxThreadHandle</a></td></tr>
<tr class="memdesc:a642ee21944f2c0f3e122cd20c272e2b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A thread handle.  <a href="#a642ee21944f2c0f3e122cd20c272e2b3">More...</a><br/></td></tr>
<tr class="separator:a642ee21944f2c0f3e122cd20c272e2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga449976458a084f880dc8e3d29e7eb6f5"><td class="memItemLeft" align="right" valign="top">typedef unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_o_s.html#ga449976458a084f880dc8e3d29e7eb6f5">bool_t</a></td></tr>
<tr class="memdesc:ga449976458a084f880dc8e3d29e7eb6f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various integer sizes.  <a href="group___g_o_s.html#ga449976458a084f880dc8e3d29e7eb6f5">More...</a><br/></td></tr>
<tr class="separator:ga449976458a084f880dc8e3d29e7eb6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad64db2ca4caafeffec7b5cc14d56806a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_o_s.html#gad64db2ca4caafeffec7b5cc14d56806a">DECLARE_THREAD_FUNCTION</a>(fnName, param)&#160;&#160;&#160;threadreturn_t fnName(void *param)</td></tr>
<tr class="memdesc:gad64db2ca4caafeffec7b5cc14d56806a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a thread stack and function.  <a href="group___g_o_s.html#gad64db2ca4caafeffec7b5cc14d56806a">More...</a><br/></td></tr>
<tr class="separator:gad64db2ca4caafeffec7b5cc14d56806a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf18a0d6c4b39d531e021702e9a77984"><td class="memItemLeft" align="right" valign="top">typedef unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_o_s.html#gacf18a0d6c4b39d531e021702e9a77984">size_t</a></td></tr>
<tr class="memdesc:gacf18a0d6c4b39d531e021702e9a77984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various platform (and operating system) dependent types.  <a href="group___g_o_s.html#gacf18a0d6c4b39d531e021702e9a77984">More...</a><br/></td></tr>
<tr class="separator:gacf18a0d6c4b39d531e021702e9a77984"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ad737a9b29b047ee24953a1f367d7501a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfxHalt </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Halt the GFX application due to an error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>An optional debug message to show (Can be NULL)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

</div>
</div>
<a class="anchor" id="aa446ccfdfdd4c575e648956ae96f2a3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfxExit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exit the GFX application. </p>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

</div>
</div>
<a class="anchor" id="ab7009723240f48524fdea5d18b63966c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* gfxAlloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___g_o_s.html#gacf18a0d6c4b39d531e021702e9a77984">size_t</a>&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate memory. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the memory allocated or NULL if there is no more memory available</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>The size in bytes of the area to allocate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

</div>
</div>
<a class="anchor" id="a7d499dfdb43e7a4e19c6f00c7f0d51c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* gfxRealloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___g_o_s.html#gacf18a0d6c4b39d531e021702e9a77984">size_t</a>&#160;</td>
          <td class="paramname"><em>oldsz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___g_o_s.html#gacf18a0d6c4b39d531e021702e9a77984">size_t</a>&#160;</td>
          <td class="paramname"><em>newsz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Re-allocate memory. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the new memory area or NULL if there is no more memory available</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>The old memory area to be increased/decreased in size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oldsz</td><td>The size in bytes of the old memory area </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newsz</td><td>The size in bytes of the new memory area</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Some operating systems don't use the oldsz parameter as they implicitly know the size of old memory area. The parameter must always be supplied however for API compatibility. </dd>
<dd>
<a class="el" href="gos_8h.html#a7d499dfdb43e7a4e19c6f00c7f0d51c9" title="Re-allocate memory. ">gfxRealloc()</a> can make the area smaller or larger but may have to return a different pointer. If this occurs the new area contains a copy of the data from the old area. The old memory pointer should not be used after this routine as the original area may have been freed. </dd>
<dd>
If there is insufficient memory to create the new memory region, NULL is returned and the old memory area is left unchanged.</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

</div>
</div>
<a class="anchor" id="ae35da30b7a140abbaa7892d8a1fc0b78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfxFree </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>The memory to free</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

<p>Referenced by <a class="el" href="group___mouse.html#ga3e624fb79c9442f50195fe7ebb97b0d3">ginputGetMouse()</a>.</p>

</div>
</div>
<a class="anchor" id="a48e13e354721ffac812c59d360956556"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfxYield </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yield the current thread. </p>
<p>Give up the rest of the current time slice for this thread in order to give other threads a chance to run.</p>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

</div>
</div>
<a class="anchor" id="a9c25311a0069cb77efef056190c6adb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfxSleepMilliseconds </td>
          <td>(</td>
          <td class="paramtype">delaytime_t&#160;</td>
          <td class="paramname"><em>ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put the current thread to sleep for the specified period in milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ms</td><td>The number milliseconds to sleep</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Specifying TIME_IMMEDIATE will yield the current thread but return on the next time slice. </dd>
<dd>
Specifying TIME_INFINITE will sleep forever.</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

<p>Referenced by <a class="el" href="group___mouse.html#gaa7516321c024ea1368e076c414dc3aac">ginputCalibrateMouse()</a>, <a class="el" href="group___mouse.html#gabc4f926c4f63e2634fca3078147fe13c">ginputGetMouseStatus()</a>, and <a class="el" href="group___toggle.html#ga27ac510620308fc67e349d23e792330f">ginputGetToggleStatus()</a>.</p>

</div>
</div>
<a class="anchor" id="a0924aee637981f2be6752f6c6bebd1bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfxSleepMicroseconds </td>
          <td>(</td>
          <td class="paramtype">delaytime_t&#160;</td>
          <td class="paramname"><em>ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put the current thread to sleep for the specified period in microseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ms</td><td>The number microseconds to sleep</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Specifying TIME_IMMEDIATE will return immediately (no sleeping) </dd>
<dd>
Specifying TIME_INFINITE will sleep forever.</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

</div>
</div>
<a class="anchor" id="a19830585f588833a50c6e8c81f32bc23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">systemticks_t gfxSystemTicks </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current operating system tick time. </p>
<dl class="section return"><dt>Returns</dt><dd>The current tick time</dd></dl>
<dl class="section note"><dt>Note</dt><dd>A "tick" is an arbitrary period of time that the operating system uses to mark time. </dd>
<dd>
The absolute value of this call is relatively meaningless. Its usefulness is in calculating periods between two calls to this function. </dd>
<dd>
As the value from this function can wrap it is important that any periods are calculated as t2 - t1 and then compared to the desired period rather than comparing t1 + period to t2</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

<p>Referenced by <a class="el" href="group___g_t_i_m_e_r.html#gac5391b998453315ac451780abc7ed40b">gtimerStart()</a>.</p>

</div>
</div>
<a class="anchor" id="a41d570620c96ea96590535f6e91a2c50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">systemticks_t gfxMillisecondsToTicks </td>
          <td>(</td>
          <td class="paramtype">delaytime_t&#160;</td>
          <td class="paramname"><em>ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a given number of millseconds to a number of operating system ticks. </p>
<dl class="section return"><dt>Returns</dt><dd>The period in system ticks.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>A "tick" is an arbitrary period of time that the operating system uses to mark time.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ms</td><td>The number of millseconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

<p>Referenced by <a class="el" href="group___g_t_i_m_e_r.html#gac5391b998453315ac451780abc7ed40b">gtimerStart()</a>.</p>

</div>
</div>
<a class="anchor" id="aacc20160d9f65e7e3d506f725123b2db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfxSystemLock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock the operating system to protect a sequence of code. </p>
<dl class="section note"><dt>Note</dt><dd>Calling this will lock out all other threads from executing even at interrupt level within the GFX system. On hardware this may be implemented as a disabling of interrupts, however in an operating system which hides real interrupt level code it may simply use a mutex lock. </dd>
<dd>
The thread MUST NOT block whilst the system is locked. It must execute in this state for as short a period as possible as this can seriously affect interrupt latency on some platforms. </dd>
<dd>
While locked only interrupt level (iclass) GFX routines may be called.</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

</div>
</div>
<a class="anchor" id="aa59c0143ca45eac02a21fdb67b75e4e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfxSystemUnlock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock the operating system previous locked by <a class="el" href="gos_8h.html#aacc20160d9f65e7e3d506f725123b2db" title="Lock the operating system to protect a sequence of code. ">gfxSystemLock()</a> </p>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

</div>
</div>
<a class="anchor" id="a2ca36f9a37de74f155ae66a544ec6ea2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfxMutexInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgfx_mutex.html">gfxMutex</a> *&#160;</td>
          <td class="paramname"><em>pmutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise a mutex to protect a region of code from other threads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pmutex</td><td>A pointer to the mutex</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Whilst a counting semaphore with a limit of 1 can be used for similiar purposes on many operating systems using a seperate mutex structure is more efficient.</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

</div>
</div>
<a class="anchor" id="ab1103102fd5edd1687f9ba6253279dec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfxMutexDestroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgfx_mutex.html">gfxMutex</a> *&#160;</td>
          <td class="paramname"><em>pmutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a Mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pmutex</td><td>A pointer to the mutex</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

</div>
</div>
<a class="anchor" id="a64bf76af754056cb06ec673944203350"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfxMutexEnter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgfx_mutex.html">gfxMutex</a> *&#160;</td>
          <td class="paramname"><em>pmutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enter the critical code region protected by the mutex. </p>
<p>Blocks until there is no other thread in the critical region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pmutex</td><td>A pointer to the mutex</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

<p>Referenced by <a class="el" href="group___g_e_v_e_n_t.html#ga6b0df7c3f2874fee5eb84d04ccffb29f">geventAttachSource()</a>, <a class="el" href="group___g_e_v_e_n_t.html#ga4f206397749cf1c3a190953433c42876">geventDetachSource()</a>, <a class="el" href="group___g_e_v_e_n_t.html#gaf3cf7887e37a91bd8f87ee30f59aaed5">geventDetachSourceListeners()</a>, <a class="el" href="group___g_e_v_e_n_t.html#ga99d5235de5d8c8575d4d30bd642091c0">geventGetSourceListener()</a>, <a class="el" href="group___g_e_v_e_n_t.html#ga63cff599d7c2f119643eaacc60dbd68d">geventSendEvent()</a>, <a class="el" href="group___g_t_i_m_e_r.html#gae62bea98342cd51884c9dfecfe38e178">gtimerJab()</a>, <a class="el" href="group___g_t_i_m_e_r.html#gac5391b998453315ac451780abc7ed40b">gtimerStart()</a>, and <a class="el" href="group___g_t_i_m_e_r.html#gad0d6b97232566e6203fa900a475d0aa5">gtimerStop()</a>.</p>

</div>
</div>
<a class="anchor" id="a39ca335a027a51d07559e2740b22518b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfxMutexExit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgfx_mutex.html">gfxMutex</a> *&#160;</td>
          <td class="paramname"><em>pmutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exit the critical code region protected by the mutex. </p>
<p>May cause another thread waiting on the mutex to now be placed into the run queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pmutex</td><td>A pointer to the mutex</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

<p>Referenced by <a class="el" href="group___g_e_v_e_n_t.html#ga6b0df7c3f2874fee5eb84d04ccffb29f">geventAttachSource()</a>, <a class="el" href="group___g_e_v_e_n_t.html#ga4f206397749cf1c3a190953433c42876">geventDetachSource()</a>, <a class="el" href="group___g_e_v_e_n_t.html#gaf3cf7887e37a91bd8f87ee30f59aaed5">geventDetachSourceListeners()</a>, <a class="el" href="group___g_e_v_e_n_t.html#ga99d5235de5d8c8575d4d30bd642091c0">geventGetSourceListener()</a>, <a class="el" href="group___g_e_v_e_n_t.html#ga63cff599d7c2f119643eaacc60dbd68d">geventSendEvent()</a>, <a class="el" href="group___g_t_i_m_e_r.html#gae62bea98342cd51884c9dfecfe38e178">gtimerJab()</a>, <a class="el" href="group___g_t_i_m_e_r.html#gac5391b998453315ac451780abc7ed40b">gtimerStart()</a>, and <a class="el" href="group___g_t_i_m_e_r.html#gad0d6b97232566e6203fa900a475d0aa5">gtimerStop()</a>.</p>

</div>
</div>
<a class="anchor" id="aeebc0d40e24efc49855ec4d9291cd047"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfxSemInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgfx_sem.html">gfxSem</a> *&#160;</td>
          <td class="paramname"><em>psem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">semcount_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">semcount_t&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise a Counted Semaphore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">psem</td><td>A pointer to the semaphore </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The initial value of the semaphore </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">limit</td><td>The maxmimum value of the semaphore</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Operations defined for counted semaphores: Signal: The semaphore counter is increased and if the result is non-positive then a waiting thread is queued for execution. Note that once the thread reaches "limit", further signals are ignored. Wait: The semaphore counter is decreased and if the result becomes negative the thread is queued in the semaphore and suspended.</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

<p>Referenced by <a class="el" href="group___g_e_v_e_n_t.html#ga0a667f4c762ecbef93e65c5398bc9a14">geventListenerInit()</a>.</p>

</div>
</div>
<a class="anchor" id="a2f87a78e68239626d2adb5851d532c24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfxSemDestroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgfx_sem.html">gfxSem</a> *&#160;</td>
          <td class="paramname"><em>psem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a Counted Semaphore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">psem</td><td>A pointer to the semaphore</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Any threads waiting on the semaphore will be released</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

</div>
</div>
<a class="anchor" id="ac3d1b2e8df8c9d69ddc4df6df650563a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___g_o_s.html#ga449976458a084f880dc8e3d29e7eb6f5">bool_t</a> gfxSemWait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgfx_sem.html">gfxSem</a> *&#160;</td>
          <td class="paramname"><em>psem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">delaytime_t&#160;</td>
          <td class="paramname"><em>ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait on a semaphore. </p>
<p>The semaphore counter is decreased and if the result becomes negative the thread waits for it to become non-negative again </p>
<dl class="section return"><dt>Returns</dt><dd>FALSE if the wait timeout occurred otherwise TRUE</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">psem</td><td>A pointer to the semaphore </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ms</td><td>The maximum time to wait for the semaphore</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

<p>Referenced by <a class="el" href="group___g_e_v_e_n_t.html#ga6b0df7c3f2874fee5eb84d04ccffb29f">geventAttachSource()</a>, <a class="el" href="group___g_e_v_e_n_t.html#ga4f206397749cf1c3a190953433c42876">geventDetachSource()</a>, <a class="el" href="group___g_e_v_e_n_t.html#gacc6f42ae21d9fc77a00d4046f1c0fc03">geventEventWait()</a>, and <a class="el" href="group___g_e_v_e_n_t.html#ga99d5235de5d8c8575d4d30bd642091c0">geventGetSourceListener()</a>.</p>

</div>
</div>
<a class="anchor" id="aaedf65e9e766d053a2a9cd947f190743"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfxSemSignal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgfx_sem.html">gfxSem</a> *&#160;</td>
          <td class="paramname"><em>psem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signal a semaphore. </p>
<p>The semaphore counter is increased and if the result is non-positive then a waiting thread is queued for execution. Note that once the thread reaches "limit", further signals are ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">psem</td><td>A pointer to the semaphore</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

<p>Referenced by <a class="el" href="group___g_e_v_e_n_t.html#ga6b0df7c3f2874fee5eb84d04ccffb29f">geventAttachSource()</a>, <a class="el" href="group___g_e_v_e_n_t.html#ga4f206397749cf1c3a190953433c42876">geventDetachSource()</a>, <a class="el" href="group___g_e_v_e_n_t.html#ga99d5235de5d8c8575d4d30bd642091c0">geventGetSourceListener()</a>, <a class="el" href="group___g_e_v_e_n_t.html#ga63cff599d7c2f119643eaacc60dbd68d">geventSendEvent()</a>, <a class="el" href="group___g_t_i_m_e_r.html#gae62bea98342cd51884c9dfecfe38e178">gtimerJab()</a>, and <a class="el" href="group___g_t_i_m_e_r.html#gac5391b998453315ac451780abc7ed40b">gtimerStart()</a>.</p>

</div>
</div>
<a class="anchor" id="a68f475f56ff6a38027c73c2dd17889b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfxSemSignalI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgfx_sem.html">gfxSem</a> *&#160;</td>
          <td class="paramname"><em>psem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signal a semaphore. </p>
<p>The semaphore counter is increased and if the result is non-positive then a waiting thread is queued for execution. Note that once the thread reaches "limit", further signals are ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">psem</td><td>A pointer to the semaphore</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Class:</dt><dd>This is an <b>I-Class</b> API, this function can be invoked from within a system lock zone by both threads and interrupt handlers. </dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

<p>Referenced by <a class="el" href="group___g_t_i_m_e_r.html#ga6806d7954f9b661cfbde689d8efb0236">gtimerJabI()</a>.</p>

</div>
</div>
<a class="anchor" id="a2c9c471ce112d0a9210a5e84d996aca7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">semcount_t gfxSemCounter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgfx_sem.html">gfxSem</a> *&#160;</td>
          <td class="paramname"><em>psem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current semaphore count. </p>
<dl class="section return"><dt>Returns</dt><dd>The current semaphore count</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">psem</td><td>A pointer to the semaphore</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

<p>Referenced by <a class="el" href="group___g_e_v_e_n_t.html#ga4f206397749cf1c3a190953433c42876">geventDetachSource()</a>, <a class="el" href="group___g_e_v_e_n_t.html#gacc6f42ae21d9fc77a00d4046f1c0fc03">geventEventWait()</a>, <a class="el" href="group___g_e_v_e_n_t.html#gaa927b8fce706b27bbcefc82915b3e776">geventGetEventBuffer()</a>, and <a class="el" href="group___g_e_v_e_n_t.html#ga63cff599d7c2f119643eaacc60dbd68d">geventSendEvent()</a>.</p>

</div>
</div>
<a class="anchor" id="a8f423c871e3daebd5db78b5e74e431fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">semcount_t gfxSemCounterI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgfx_sem.html">gfxSem</a> *&#160;</td>
          <td class="paramname"><em>psem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current semaphore count. </p>
<dl class="section return"><dt>Returns</dt><dd>The current semaphore count</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">psem</td><td>A pointer to the semaphore</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Class:</dt><dd>This is an <b>I-Class</b> API, this function can be invoked from within a system lock zone by both threads and interrupt handlers. </dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

</div>
</div>
<a class="anchor" id="aee5bfa81d284cf05bceaa54094e14377"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="gos_8h.html#a642ee21944f2c0f3e122cd20c272e2b3">gfxThreadHandle</a> gfxThreadCreate </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>stackarea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___g_o_s.html#gacf18a0d6c4b39d531e021702e9a77984">size_t</a>&#160;</td>
          <td class="paramname"><em>stacksz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">threadpriority_t&#160;</td>
          <td class="paramname"><em>prio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___g_o_s.html#gad64db2ca4caafeffec7b5cc14d56806a">DECLARE_THREAD_FUNCTION</a>((*fn), p)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a new thread. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a thread handle if the thread was started, NULL on an error</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stackarea</td><td>A pointer to the area for the new threads stack or NULL to dynamically allocate it </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stacksz</td><td>The size of the thread stack. 0 means the default operating system size although this is only valid when stackarea is dynamically allocated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prio</td><td>The priority of the new thread </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fn</td><td>The function the new thread will run </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>A parameter to pass the thread function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

<p>Referenced by <a class="el" href="group___g_t_i_m_e_r.html#gac5391b998453315ac451780abc7ed40b">gtimerStart()</a>.</p>

</div>
</div>
<a class="anchor" id="a83eafa3bb719227aaa2cdff9b0657354"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">threadreturn_t gfxThreadWait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gos_8h.html#a642ee21944f2c0f3e122cd20c272e2b3">gfxThreadHandle</a>&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for a thread to finish. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the thread exit code.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>The Thread Handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This will also close the thread handle as it is no longer useful once the thread has ended. </dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

</div>
</div>
<a class="anchor" id="a21d56c2744416cf21919a28ecedc79ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="gos_8h.html#a642ee21944f2c0f3e122cd20c272e2b3">gfxThreadHandle</a> gfxThreadMe </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current thread handle. </p>
<dl class="section return"><dt>Returns</dt><dd>A thread handle</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

</div>
</div>
<a class="anchor" id="a3537b26f39e3389827635dcf370ab134"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gfxThreadClose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gos_8h.html#a642ee21944f2c0f3e122cd20c272e2b3">gfxThreadHandle</a>&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close the thread handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>The Thread Handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This does not affect the thread, it just closes our handle to the thread.</dd></dl>
<dl class="section user"><dt>Function Class:</dt><dd>Normal API, this function can be invoked by regular system threads but not from within a lock zone. </dd></dl>

<p>Referenced by <a class="el" href="group___g_t_i_m_e_r.html#gac5391b998453315ac451780abc7ed40b">gtimerStart()</a>.</p>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="aa93f0eb578d23995850d61f7d61c55c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FALSE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various platform (and operating system) constants. </p>
<dl class="section note"><dt>Note</dt><dd>Your platform may use slightly different definitions to these </dd></dl>

<p>Definition at line <a class="el" href="gos_8h_source.html#l00070">70</a> of file <a class="el" href="gos_8h_source.html">gos.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a642ee21944f2c0f3e122cd20c272e2b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="gos_8h.html#a642ee21944f2c0f3e122cd20c272e2b3">gfxThreadHandle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A thread handle. </p>
<dl class="section note"><dt>Note</dt><dd>Your operating system will have a proper definition for this. </dd></dl>

<p>Definition at line <a class="el" href="gos_8h_source.html#l00096">96</a> of file <a class="el" href="gos_8h_source.html">gos.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_75b82e7e4a5feb05200b9ad7adf06257.html">home</a></li><li class="navelem"><a class="el" href="dir_666fe4ffcfa5861974795d583e327f01.html">tectu</a></li><li class="navelem"><a class="el" href="dir_2e1b698069f5ea22a2e6af189afce14a.html">projects</a></li><li class="navelem"><a class="el" href="dir_ba227d9595d369abd0022216bad2fbc6.html">resources</a></li><li class="navelem"><a class="el" href="dir_ec72f105347e0b49c101f60ea1ec71f2.html">ugfx</a></li><li class="navelem"><a class="el" href="dir_765793e2f223359f0a59642504c9bd32.html">include</a></li><li class="navelem"><a class="el" href="dir_715d1672f14b2f45f28a655e29c5aef8.html">gos</a></li><li class="navelem"><a class="el" href="gos_8h.html">gos.h</a></li>
    <li class="footer">Generated on Sun Nov 10 2013 23:06:13 for uGFX by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
